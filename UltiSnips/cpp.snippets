# Snippets for generating bde-formatted code in C++ files

global !p
import parseutil
import sniputil
from sectiontype import SectionType


def clearSnipLine(snip):
	"""
	Clear the current line of the specified 'snip' and set the current
	position to the beginning of it.
	"""
	snip.buffer[snip.line] = ""
	snip.cursor.set(snip.line, 0)

def extractClassSectionAnywhere(className, section):
    """
    Use 'parseutil.extractClassSection' to attempt to find the specified
    'section' of the specified 'class'.  If it's not found in the current
    file, and the current file is a .cpp, open the corresponding .h and try to
    find it there before giving up.
    """

    def lineGen():
        for line in range(0, len(vim.current.buffer)):
            yield vim.current.buffer[line]

    content = parseutil.extractClassSection(lineGen(), className, section)
    if content != None:
        return content

    # See if we can load the header,  and find the section there
    bufName = vim.current.buffer.name
    if not bufName.endswith(".cpp"):
        return None

    bufName = bufName.replace(".cpp", ".h")
    try:
        with open(bufName) as f:
            def hLineGen():
                for line in f:
                    yield line.rstrip("\n")

            content = parseutil.extractClassSection(hLineGen(),
                                                    className,
                                                    section)
    except e:
        # File doesn't exist.  Do nothing; content will remain None
        pass

    return content

def expandCctorSnippet(snip):
	"""
	Generate and expand a snippet for a copy constructor, using the
	'snip.visual_content' as the data members to initialize, or by searching
	for the members of the closest class otherwise.
	"""
	def lineGen(start, end):
		step = 1 if start < end else -1
		for line in range(start, end, step):
			yield snip.buffer[line]

	classname = parseutil.findClassName(lineGen(snip.line, 0))

	memberDefs = snip.visual_content
	if len(memberDefs) == 0 and len(classname) > 0:
		# Find the members section of the classname
		memberDefs = extractClassSectionAnywhere(classname, SectionType.DATA)

	clearSnipLine(snip)
	snip.expand_anon(sniputil.genCctorSnippet(classname, memberDefs))

def expandCtorMemSnippet(snip):
	"""
	Generate and expand a snippet for the constructor initialization of member
	variables using the specified 'snip'.
	"""

	# If line above snip.line starts with ', ' or ': ' then we'll start with
	# ', ', otherwise we'll start with ': '
	prevLine = snip.buffer[snip.line - 1].strip()
	separator = ", " if (prevLine.startswith(": ") or
						 prevLine.startswith(", ")) else \
				": "

	members = snip.visual_content
	if len(members) == 0:
		# Find the classname
		def lineGen(start, end):
			step = 1 if start < end else -1
			for line in range(start, end, step):
				yield snip.buffer[line]

		classname = parseutil.findClassName(lineGen(snip.line, 0))
		if len(classname) > 0:
			# Find the members section of the classname
			members = extractClassSectionAnywhere(classname, SectionType.DATA)

	clearSnipLine(snip)
	snip.expand_anon(sniputil.genCtorMemSnippet(members, separator))

def expandDefSnippet(snip):
	"""
	Generate a snippet for the definitions of the declarations either in the
	current visual_content, or the current class's current section.  If the
	specified 'inHeader' is 'True', prepend each definition with an 'inline'.
	"""

	bufName = vim.current.buffer.name
	inHeader = bufName.endswith(".h")

	def lineGen():
		for line in range(snip.line, 0, -1):
			yield snip.buffer[line]

	classname = parseutil.findClassName(lineGen())
	if not classname:
		raise Error("Need to be under a BDE class/struct heading")

	decls = snip.visual_content
	if len(decls) == 0:
		# Search up for a section name, and find the corresponding section in
		# the class definition to pull declarations from
		section = None
		for line in range(snip.line, 0, -1):
			section = SectionType.check(snip.buffer[line])
			if section == SectionType.ACCESSORS or \
			   section == SectionType.PRIVATE_ACCESSORS or \
			   section == SectionType.MANIPULATORS or \
			   section == SectionType.PRIVATE_MANIPULATORS:
				break

		if not section:
			raise Error("Need to be in a bde section, or have visual content")

		decls = extractClassSectionAnywhere(classname, section)
		if not decls:
			raise Error("Can't find section %s in class %s" % \
														  (section, classname))

	clearSnipLine(snip)
	snip.expand_anon(sniputil.genDefSnippet(classname, decls, inHeader))

def expandDeclSnippet(snip, manipSetters = False):

	# Find the classname
	def lineGen(start, end):
		step = 1 if start < end else -1
		for line in range(start, end, step):
			yield snip.buffer[line]

	classname = parseutil.findClassName(lineGen(snip.line, 0))
	if not classname:
		raise Exception("Need to be under a BDE class/struct heading")

	# Determine the member definitions to use
	memberDefs = snip.visual_content
	if len(memberDefs) == 0 and len(classname) > 0:
		# Find the members section of the classname

		memberDefs = parseutil.extractClassSection(
												  lineGen(0, len(snip.buffer)),
												  classname,
												  SectionType.DATA)

	# See if we're under an ACCESSORS or MANIPULATORS heading
	section = None
	for line in lineGen(snip.line, 0):
		section = SectionType.check(line)
		if section == SectionType.CREATORS or \
		   section == SectionType.PRIVATE_CREATORS or \
		   section == SectionType.ACCESSORS or \
		   section == SectionType.PRIVATE_ACCESSORS or \
		   section == SectionType.MANIPULATORS or \
		   section == SectionType.PRIVATE_MANIPULATORS:
			break

	if section != SectionType.ACCESSORS and \
	   section != SectionType.MANIPULATORS:
		raise Exception("Need to be under an ACCESSORS or MANIPULATORS header")

	if section == SectionType.ACCESSORS:
		snipText = sniputil.genDeclSnippet(memberDefs,
										   sniputil.genAccessorDeclSnippet)
	elif section == SectionType.MANIPULATORS:
		if manipSetters:
			snipText = sniputil.genDeclSnippet(memberDefs,
											   sniputil.genSetterDeclSnippet)
		else:
			snipText = sniputil.genDeclSnippet(
								            memberDefs,
								            sniputil.genManipulatorDeclSnippet)

	clearSnipLine(snip)
	snip.expand_anon(snipText)

endglobal

                                   # #####
                                   # cctor
                                   # #####

pre_expand "expandCctorSnippet(snip)"
snippet cctor
endsnippet

                                  # #######
                                  # ctormem
                                  # #######

pre_expand "expandCtorMemSnippet(snip)"
snippet ctormem
endsnippet

                                    # ###
                                    # def
                                    # ###

pre_expand "expandDefSnippet(snip)"
snippet def
endsnippet

                                    # ####
                                    # decl
                                    # ####

pre_expand "expandDeclSnippet(snip)"
snippet decl
endsnippet

                                # ############
                                # decl_setters
                                # ############

pre_expand "expandDeclSnippet(snip, True)"
snippet decl_setters
endsnippet
